<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>Bitmasking - 2</h1>
    <h2>Covered in this section: </h2>
    <ul>
        <li>Properties related to Bitmasking done via questions</li>
    </ul>
    <h2>Properties</h2>
    <ul>
        <li>
            <code>x^0 = x</code>
            <p>Xor of any number with 0 is the number itself.</p>
        </li>
        <li>
            <code>x^x = 1</code>
            <p>XOR of any number with itself is 0 because each bit cancels itself out. For example, 5 ^ 5 = 0.</p>
            <p><a href="https://leetcode.com/problems/single-number/description/" target="_blank">This problem </a>utilises above mentioned properties</p>
            <p><a href="https://leetcode.com/problems/missing-number/description/"target="_blank">This problem </a>utilises above mentioned properties
                but is slightly more complicated than the first problem</p>
        </li>
        <li>
            <h3>Hamming Distance(a,b)</h3>
            <p>Hamming distance between two integers (or binary strings) is the number of bit positions at which the corresponding bits are different.
                Example: 
                x = 5  →  0101
                y = 3  →  0011
                Hamming distance = 2 (1, 2 index);
            </p>
            <pre>
                <code>
                    int hammingDistance(int x, int y) {
                        return __builtin_popcount(x ^ y); // XOR + count set bits
                    }                    
                </code>
            </pre>
            <p><a href="https://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/" target="_blank">This problem</a> utlizes hamming 
            distance concepts.</p>
        </li>
        <li>
            <h3>Set of all subsets os a set</h3>
            <p>
                Each subset of a given array can be represented by a binary number, where each bit indicates whether to include a particular element. 
                By looping from <code>0</code> to <code>2<sup>n</sup> - 1</code>, we generate all possible combinations. 
                For each number <code>i</code>, the expression <code>(i >> j) & 1</code> checks if the <code>j</code>-th bit is set. 
                If it is, we include <code>nums[j]</code> in the current subset. 
                For example, if <code>nums = [1, 2, 3]</code> and <code>i = 5</code> (binary <code>101</code>), we include <code>nums[0]</code> and <code>nums[2]</code>, 
                resulting in the subset <code>[1, 3]</code>. This method efficiently generates all subsets using bitmasking.
            </p>
            <p><a href="https://leetcode.com/problems/subsets/" target="_blank">This problem</a> ultilises the property above.</p>
                
                
        </li>
    </ul>
</body>
</html>